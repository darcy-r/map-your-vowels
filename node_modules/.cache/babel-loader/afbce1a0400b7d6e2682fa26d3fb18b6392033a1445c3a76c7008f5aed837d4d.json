{"ast":null,"code":"export const normalisationMethods = [\"none\", \"Lobanov\", \"Nearey 1\", \"Nearey 2\"];\nconst e = Math.exp(1);\nfunction antilog(n) {\n  let base = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : e;\n  if (base === e) return Math.exp(n);\n  return Math.pow(base, n);\n}\nfunction average(inputArray) {\n  return inputArray.reduce((a, b) => a + b, 0) / inputArray.length;\n}\nfunction standardDeviation(array) {\n  const n = array.length;\n  const mean = array.reduce((a, b) => a + b) / n;\n  return Math.sqrt(array.map(x => Math.pow(x - mean, 2)).reduce((a, b) => a + b) / n);\n}\nfunction normaliseFormantNearey1(formantN, allNFormants) {\n  return antilog(Math.log(formantN) - average(allNFormants.map(f => Math.log(f))));\n}\nfunction normaliseFormantNearey2(formantN, allFormants) {\n  return antilog(Math.log(formantN) - average(allFormants.map(f => Math.log(f))));\n}\nfunction normaliseFormantLobanov(formant, meanFormant, stdDevFormant) {\n  return (formant - meanFormant) / stdDevFormant;\n}\nfunction normaliseFormant(method, formantN, allNFormants, allFormants, meanNFormant, stdDevNFormant) {\n  switch (method) {\n    case \"Lobanov\":\n      return normaliseFormantLobanov(formantN, meanNFormant, stdDevNFormant);\n    case \"Nearey 1\":\n      return normaliseFormantNearey1(formantN, allNFormants);\n    case \"Nearey 2\":\n      return normaliseFormantNearey2(formantN, allFormants);\n  }\n}\nexport function normaliseDataset(dataset, method) {\n  if (!dataset | dataset.length == 0) {\n    return dataset;\n  }\n  if (method == \"none\") {\n    return dataset;\n  }\n  const f1s = dataset.map(row => row[\"f1\"]);\n  const f2s = dataset.map(row => row[\"f2\"]);\n  const meanF1 = average(f1s);\n  const meanF2 = average(f2s);\n  let stdDevF1;\n  let stdDevF2;\n  if (method == \"Lobanov\") {\n    stdDevF1 = standardDeviation(f1s);\n    stdDevF2 = standardDeviation(f2s);\n  }\n  for (let i = 0; i < dataset.length; i++) {\n    dataset[i][\"normalisedF1\"] = normaliseFormant(method, dataset[i][\"f1\"], f1s, f1s.concat(f2s), meanF1, stdDevF1);\n    dataset[i][\"normalisedF2\"] = normaliseFormant(method, dataset[i][\"f2\"], f2s, f1s.concat(f2s), meanF2, stdDevF2);\n  }\n  return dataset;\n}","map":{"version":3,"names":["normalisationMethods","e","Math","exp","antilog","n","base","arguments","length","undefined","pow","average","inputArray","reduce","a","b","standardDeviation","array","mean","sqrt","map","x","normaliseFormantNearey1","formantN","allNFormants","log","f","normaliseFormantNearey2","allFormants","normaliseFormantLobanov","formant","meanFormant","stdDevFormant","normaliseFormant","method","meanNFormant","stdDevNFormant","normaliseDataset","dataset","f1s","row","f2s","meanF1","meanF2","stdDevF1","stdDevF2","i","concat"],"sources":["/Users/darcyroche/Documents/GitHub/map-your-vowels/src/normalisation.js"],"sourcesContent":["export const normalisationMethods = [\n  \"none\", \"Lobanov\", \"Nearey 1\", \"Nearey 2\"\n]\n\nconst e = Math.exp(1)\n\nfunction antilog(n, base = e) {\n  if (base === e) return Math.exp(n);\n  return Math.pow(base, n);\n}\n\nfunction average(inputArray) {\n  return inputArray.reduce((a, b) => a + b, 0) / inputArray.length;\n}\n\nfunction standardDeviation (array) {\n  const n = array.length;\n  const mean = array.reduce((a, b) => a + b) / n;\n  return Math.sqrt(array.map(x => Math.pow(x - mean, 2)).reduce((a, b) => a + b) / n);\n}\n\nfunction normaliseFormantNearey1(formantN, allNFormants) {\n  return antilog(Math.log(formantN) - average(allNFormants.map(f => Math.log(f))));\n}\n\nfunction normaliseFormantNearey2(formantN, allFormants) {\n  return antilog(Math.log(formantN) - average(allFormants.map(f => Math.log(f))));\n}\n\nfunction normaliseFormantLobanov(formant, meanFormant, stdDevFormant) {\n  return (formant - meanFormant) / stdDevFormant;\n}\n\nfunction normaliseFormant(method, formantN, allNFormants, allFormants, meanNFormant, stdDevNFormant) {\n  switch (method) {\n    case \"Lobanov\":\n      return normaliseFormantLobanov(formantN, meanNFormant, stdDevNFormant);\n    case \"Nearey 1\":\n      return normaliseFormantNearey1(formantN, allNFormants);\n    case \"Nearey 2\":\n      return normaliseFormantNearey2(formantN, allFormants)\n  }\n}\n\nexport function normaliseDataset(dataset, method) {\n  if ((! dataset) | (dataset.length == 0)) {\n    return dataset\n  }\n  if (method == \"none\") {\n    return dataset;\n  }\n  const f1s = dataset.map(row => row[\"f1\"]);\n  const f2s = dataset.map(row => row[\"f2\"]);\n  const meanF1 = average(f1s);\n  const meanF2 = average(f2s);\n  let stdDevF1;\n  let stdDevF2;\n  if (method == \"Lobanov\") {\n    stdDevF1 = standardDeviation(f1s);\n    stdDevF2 = standardDeviation(f2s);\n  }\n  for (let i = 0; i < dataset.length; i++) {\n    dataset[i][\"normalisedF1\"] = normaliseFormant(method, dataset[i][\"f1\"], f1s, f1s.concat(f2s), meanF1, stdDevF1);\n    dataset[i][\"normalisedF2\"] = normaliseFormant(method, dataset[i][\"f2\"], f2s, f1s.concat(f2s), meanF2, stdDevF2);\n  }\n  return dataset;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}